#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Mostly inspired by
# http://mail.python.org/pipermail/python-list/2001-February/071414.html
# and
# http://code.activestate.com/recipes/278731/


import os
import sys
import optparse
import resource

import time
import signal
import pprint
import inspect
import subprocess
import ConfigParser

import sjutils

VERSION = "@PACKAGE_VERSION@"

# Default daemon parameters.
# File mode creation mask of the daemon.
UMASK = 0

# Default working directory for the daemon.
WORKDIR = "/"

# Default maximum for the number of available file descriptors.
MAXFD = 1024

DFLT_PIDFILE = "/var/run/sl2d/sl2d.pid"
DFLT_LOGPATH = "/var/log/sl2d/"
DFLT_CONFFILE = "/etc/sl2d.conf"

DFLT_MAIN_LOOP_DELAY = 15
DFLT_RESPAWN_MIN_DELAY = 5

# The standard I/O file descriptors are redirected to /dev/null by default.
if (hasattr(os, "devnull")):
    REDIRECT_TO = os.devnull
else:
    REDIRECT_TO = "/dev/null"

OPTIONS = {
    # Unclassified settings
    'format':       'f',
    'flags':        'flags',
    'flags2':       'flags2',
    'partitions':   'partitions',
    'coder':        'coder',
    'refs':         'refs',
    'threads':      'threads',

    # Audio settings known by ffserver
    'audio_codec':       'acodec',
    'audio_volume':      'vol',
    'audio_bit_rate':    'ab',
    'audio_channels':    'ac',
    'audio_sample_rate': 'ar',

    # Video settings known by ffserver
    'video_codec':      'vcodec',
    'video_bit_rate':   'b',
    'video_size':       's',
    'video_gop_size':   'g',
    'video_q_min':      'qmin',
    'video_q_max':      'qmax',
    'video_frame_rate': 'r',

    # Other video settings
    'video_macroblock_decision': 'mbd',
    'video_macroblock_l_max':    'mblmax',
    'video_l_max':               'lmax',
    'video_q_comp':              'qcomp',
    'video_q_diff':              'qdiff',
    'video_b_frames':            'bf',
    'video_b_strategy':          'b_strategy',
    'video_i_q_factor':          'i_qfactor',
    'video_sc_threshold':        'sc_threshold',
    'video_direct_pred':         'directpred',
    'video_me_method':           'me_method',
    'video_me_range':            'me_range',
    'video_cmp':                 'cmp',
    'video_sub_q':               'subq',
    'video_keyint_min':          'keyint_min',
    'video_sync_method':         'vsync',
    'video_trellis':             'trellis',
    'video_crop_left':           'cropleft',
    'video_crop_right':          'cropright',
    'video_crop_top':            'croptop',
    'video_crop_bottom':         'cropbottom',
    'video_pad_left':            'padleft',
    'video_pad_right':           'padright',
    'video_pad_top':             'padtop',
    'video_pad_bottom':          'padbottom',
    'video_pad_color':           'padcolor',

    'audio_sync_method':         'async',
}

OPTIONS_SINGLE = {
    'video_copy_timestamps': 'copyts',
    'video_deinterlace':     'deinterlace',
}

def flatten(x):
    """flatten(sequence) -> list

    Returns a single, flat list which contains all elements retrieved
    from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, MyVector(8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]"""

    # This code was taken from http://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks
    # Similar code was also found on python mailing lists.

    result = []
    for el in x:
        if hasattr(el, "__iter__") and not isinstance(el, basestring):
            result.extend(flatten(el))
        else:
            result.append(el)
    return result

class MonitorLogger:

    def __init__(self, section, logpath=None, debug_level=0):
        """ Init method. """

        self.logfile = ""
        self.section = section

        if logpath and os.path.exists(logpath) and os.path.isdir(logpath):
            self.logfile = os.path.sep.join((logpath, section + '.log'))
            self.log = sjutils.Logger2(self.logfile)
            self.log.redirect_stdout_stderr()
            self.closable = True
        else:
            # This is not portable but who cares ?
            self.log = sjutils.Logger2('/dev/stdout')
            self.closable = False

        self.level = debug_level

    def close(self):
        """ Close whatever needs to be closed. """

        if self.closable:
            self.log.close()

    def get_log_file(self):
        """ Returns filename as appropriate. """

        return self.closable and open(self.logfile, 'a') or open('/dev/stdout', 'a')

    def write(self, level, message):
        """ Write a message to the log file. """

        if level <= self.level:
            self.log.write('[%s] %s' % (self.section, message))

class Monitor:

    def __init__(self, monitor_options):
        """ Init method. """

        self.schedule = {}
        self.process_list = {}
        self.commands = []

        self.main_loop_delay = DFLT_MAIN_LOOP_DELAY
        self.respawn_min_delay = DFLT_RESPAWN_MIN_DELAY
        self.respawn_quick = False
        self.verbosity = monitor_options.verbosity
        self.logpath = monitor_options.logpath

        self.daemon = not monitor_options.nodaemon
        if self.daemon:
            self.log = MonitorLogger('sl2d', logpath=self.logpath, debug_level=self.verbosity)
        else:
            self.log = MonitorLogger('sl2d', debug_level=self.verbosity)

        self.log.write(0, "*** sl2d version %s, init ***" % VERSION)
        self.parse_config(monitor_options.conffile)

        signal.signal(signal.SIGTERM, self.shutdown)
        signal.signal(signal.SIGINT,  self.shutdown)
        signal.signal(signal.SIGCHLD, self.child_shutdown)

    def parse_config(self, configfile):
        """ Parse sl2d configuration file. """

        self.commands = []
        config = ConfigParser.RawConfigParser()
        config.read(configfile)

        # Get the settings from the main section
        options = dict(config.items('sl2d'))
        self.main_loop_delay = float(options['main_loop_delay'])
        self.respawn_min_delay = float(options['respawn_min_delay'])

        for section in config.sections():
            options = dict(config.items(section))

            # Skip [sl2d] since we took care of this earlier
            if section == "sl2d":
                continue

            # Prepare logger for this command
            if self.daemon:
                logger = MonitorLogger(section, logpath=self.logpath, debug_level=self.verbosity)
            else:
                logger = MonitorLogger(section, debug_level=self.verbosity)

            # There can only be push sections here
            # binary option must be defined
            command = [ [ options['binary'], '-v', '0'] ]

            # Threads must go in first position to do any difference
            if 'threads' in options:
                command += [ "-threads %s" % options.pop('threads') ]

            # pre and post commands are optional
            precommand = []
            postcommand = []

            # Extract pre/post commands if any
            cmd_id = 1
            while 'precommand-%d' % cmd_id in options:
                cmd = options['precommand-%d' % cmd_id]
                precommand += [ [arg for arg in cmd.split(' ') if arg] ]
                cmd_id = cmd_id+1
            logger.write(0, "found %d precommand(s)" % len(precommand))

            cmd_id = 1
            while 'postcommand-%d' % cmd_id in options:
                cmd = options['postcommand-%d' % cmd_id]
                postcommand += [ [arg for arg in cmd.split(' ') if arg] ]
                cmd_id = cmd_id+1
            logger.write(0, "found %d postcommand(s)" % len(postcommand))

            url_in = options.pop('url-in')
            url_out = options.pop('url-out')
            command += [ ["-i", url_in ] ]

            # Generate the rest of the command
            command += [ ['-' + OPTIONS[setting], value]
                for (setting, value) in options.iteritems() if setting in OPTIONS]

            # Single valued parameter
            command += [ '-%s' % OPTIONS_SINGLE[setting]
                for (setting, value) in options.iteritems()
                if setting in OPTIONS_SINGLE and value in ('true', 'yes', 'on')]

            command += [ url_out ]
            self.commands += [{'pre': precommand,
                'main': flatten(command),
                'post': postcommand,
                'logger': logger,
                'section': section, }]

    def __print_process_status(self):
        """ Prints the status of process managed by sl2d. """

        self.log.write(1, "Actually running commands (%d)" % len(self.process_list))
        self.log.write(2, pprint.pformat(self.process_list))
        for pid, process in self.process_list.iteritems():
            self.log.write(1, '  * %d: %s' % (pid, process['command']['section']))

        self.log.write(1, "Scheduled commands for respawn (%d)" % len(self.schedule))
        self.log.write(2, pprint.pformat(self.schedule))
        for pid, process in self.schedule.iteritems():
            self.log.write(1, '  * %d: %s' % (pid, process['command']['section']))

    def respawn_command(self):
        """ Restart scheduled commands. """

        self.log.write(1, '<respawn_command>')
        self.__print_process_status()

        if self.respawn_quick:
            self.respawn_quick = False

        for sched_item in self.schedule.keys():

            try:
                command = self.schedule[sched_item]['command']

                # Command failed too quickly, wait next round before respawning
                if self.schedule[sched_item]['timestamp'] + self.respawn_min_delay > time.time():
                    self.log.write(0, '[%s] command respawning too fast, delayed' % (command['section']))
                    command['logger'].write(0, '"%s" respawning too fast, delayed' %  " ".join(command['main']))
                    continue

                self.log.write(0, '[%s] respawning command' % command['section'])
                command['logger'].write(0, 'respawning "%s"' % ' '.join(command['main']))
                self.start_command(self.schedule[sched_item]['command'])
                del self.schedule[sched_item]
            except KeyError:
                self.log.write(0, 'Command that had PID:%d disappeared from the queue.' % sched_item)

        self.__print_process_status()
        if self.verbosity:
            self.log.write(1, '</respawn_command>')

    def child_shutdown(self, signum, frame):
        """ Respawn command on SIGCHLD. """

        self.log.write(1, 'Received SIGCHLD')

        # Monitor status of running process
        for pid in self.process_list.keys():
            process = self.process_list[pid]['process']

            if process.poll() is not None:
                command = self.process_list[pid]['command']

                self.log.write(0, '[%s] Process %d: received signal %d' % (command['section'], pid, signum))
                self.log.write(0, '[%s] Process %d: died unexpectedly, error code is %d' % (command['section'], pid, process.poll()))
                command['logger'].write(0, 'Process %d: received signal %d' % (pid, signum))
                command['logger'].write(0, 'Process %d: died unexpectedly, error code is %d' % (pid, process.poll()))
                process.stdin.close()
                #process.stdout.close()
                #process.stderr.close()

                # Execute post commands if any and if command lived long enough.
                # Do not wait for them and do not crash for them either.
                if command['post'] and self.process_list[pid]['timestamp'] + 2 * self.respawn_min_delay > time.time() :
                    trash = os.open(REDIRECT_TO, os.O_RDWR)
                    self.log.write(0, '[%s] Process %d: spawning post-death commands' % (command['section'], pid))
                    for postcmd in command['post']:
                        try:
                            command['logger'].write(0, 'Process %d: post-death command "%s"' % (pid, ' '.join(postcmd)))
                            subprocess.Popen(postcmd, stdout=trash, stderr=STDOUT)
                        except Exception:
                            self.log.write(0, '[%s] post-death command failed', command['section'])
                            command['logger'].write(0, '[%s] Process %d: post-death command "%s" failed' % (pid, ' '.join(postcmd)))
                    os.close(trash)

                # Adding to the 'scheduled for restart' list unless we already
                # did it ealier, somehow.
                for check_pid in self.schedule:
                    if self.schedule[check_pid]['command']['section'] == command['section']:
                        self.log.write(0, '[%s] Trick to avoid duplicating commands' % command['section'])
                        break
                else:
                    self.schedule[pid] = {
                        'command': command,
                        'timestamp': self.process_list[pid]['timestamp']}
                del self.process_list[pid]

        # Inspect context to see if we are being run during respawn_command
        # execution. Set respawn_quick if necessary so that we will not
        # have to wait respawn_min_delay to respawn the command we are
        # currently treating while not interfering with current execution of
        # respawn_command.
        try:
            self.log.write(1, '<frame>')
            self.log.write(2, pprint.pformat(inspect.getframeinfo(frame)))

            for item in inspect.getouterframes(frame):
                self.log.write(2, pprint.pformat(item))
                self.log.write(1, '  * function: ' + item[3])

                if item[3] == "respawn_command":
                    self.respawn_quick = True
                    self.log.write(0, '  -> Delaying respawning')
                    break

            if self.verbosity:
                self.log.write(1, '</frame>')

            return
        finally:
            # Do not leak the frame
            del frame

        self.respawn_command()

    def shutdown(self, signum, frame):
        """ Shutdown sl2d on SIGTERM and SIGINT. """

        if frame:
            del frame

        self.__print_process_status()

        death_loop = 0
        while len(self.process_list.keys()) > 0 and death_loop < 3:
            self.log.write(0, '%d process alive' % len(self.process_list.keys()))

            for pid in self.process_list.keys():
                # shutdown ffmpeg instances
                process = self.process_list[pid]['process']
                ret = process.poll()
                if ret is None:
                    process.stdin.write('q')
                else:
                    process.stdin.close()
                    #process.stdout.close()
                    #process.stderr.close()
                    del self.process_list[pid]

            death_loop = death_loop + 1
            time.sleep(2)

        # Sick of waiting, slash 'em all
        if death_loop > 3:
            for pid in self.process_list.keys():
                os.kill(pid, signal.SIGKILL)

        self.log.write(0, "*** sl2d terminated by signal %d ***" % signum)
        self.log.close()
        if self.daemon:
            os.remove(options.pidfile)
        sys.exit(os.EX_OK)

    def start_command(self, command):
        """ Start command and store it in process_list for reference. """

        if command['pre']:
            self.log.write(0, '[%s] spawning pre-running commands' % command['section'])
            command['logger'].write(0, 'spawning pre-running commands')
            for precmd in command['pre']:
                try:
                    command['logger'].write(0, 'pre-running command "%s"' % ' '.join(precmd))
                    preprocess = subprocess.Popen(precmd,
                        stdout=command['logger'].get_log_file(),
                        stderr=subprocess.STDOUT)

                    if preprocess.wait() != 0:
                        raise Exception('return code is %d' % preprocess.poll())

                except Exception, error:
                    command['logger'].write(0, 'pre-running command "%s" failed' % ' '.join(precmd))
                    command['logger'].write(0, str(error))
                    command['logger'].write(0, 'scheduling for a retry')
                    self.log.write(0, '[%s] pre-running command failed' % command['section'])

                    # pre-commands are mandatory, schedule and return if one failed
                    self.schedule[time.time()] = {
                        'command': command,
                        'timestamp': time.time()}

                    return None

        command['logger'].write(0, 'starting "%s"' % ' '.join(command['main']))
        process = subprocess.Popen(command['main'],
            stdin=subprocess.PIPE,
            stdout=command['logger'].get_log_file(),
            stderr=subprocess.STDOUT)

        self.process_list[process.pid] = {
            'process': process,
            'command': command,
            'timestamp': time.time()}
        self.log.write(0, '[%s] Process %d: started' % (command['section'], process.pid))
        command['logger'].write(0, 'started "%s" as pid %d' % (" ".join(command['main']), process.pid))

        return process.pid

    def run(self):
        """ Main function. """

        self.log.write(0, "*** sl2d version %s, started ***" % VERSION)

        # Bookkeeping our instanciations
        self.process_list = {}
        for command in self.commands:
            self.start_command(command)

        self.__print_process_status()

        # Main loop, monitor list of scheduled restarts
        while True:
            # Shorten loop if we received SIGCHLD while respawning commands
            if not self.respawn_quick:
                time.sleep(self.main_loop_delay)
            self.respawn_command()

        self.shutdown()

def daemonize(options):
    """ Detach process from the controlling terminal and run it as a daemon. """

    if os.path.isfile(options.pidfile):
        fd = open(options.pidfile)
        old_pid = int(fd.read())
        fd.close()
        if os.path.isfile("/proc/%d/cmdline" % old_pid):
            print "There is already a running instance"
            os._exit(os.EX_OK)

    try:
        pid = os.fork()
    except OSError, error:
        raise Exception, "%s [%d]" % (error.strerror, error.errno)

    if pid == 0:
        # The first child.
        os.setsid()
        f = open(options.pidfile, 'w')
        f.write("%d" % os.getpid())
        f.close()
        Monitor(options).run()

    else:
        os._exit(os.EX_OK)

    # Resource usage information.
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = MAXFD

    # Iterate through and close all file descriptors.
    for fd in range(0, maxfd):
        try:
            os.close(fd)
        except OSError:	# ERROR, fd wasn't open to begin with (ignored)
            pass

    os.open(REDIRECT_TO, os.O_RDWR)	# standard input (0)

    # Duplicate standard input to standard output and standard error.
    os.dup2(0, 1)			# standard output (1)
    os.dup2(0, 2)			# standard error (2)

    return os.EX_OK

if __name__ == "__main__":

    parser = optparse.OptionParser(
        version="%prog " + VERSION, option_list=[
        optparse.Option("-f", "--conf",       dest="conffile",  help="Define sl2d conf file", metavar="FILE", default=DFLT_CONFFILE),
        optparse.Option("-l", "--log",        dest="logpath",   help="Define sl2d log file path", metavar="PATH", default=DFLT_LOGPATH),
        optparse.Option("-p", "--pid",        dest="pidfile",   help="Define sl2d pid file", metavar="FILE", default=DFLT_PIDFILE),
        optparse.Option("-n", "--no-daemon",  dest="nodaemon",  help="Define sl2d log file", action="store_true", default=False),
        optparse.Option("-v", "--verbose",    dest="verbosity", help="Define sl2d verbose level", action="count", default=0)]
        )

    (options, args) = parser.parse_args()

    if not options.nodaemon:
        retCode = daemonize(options)
    else:
        Monitor(options).run()

    sys.exit(retCode)

